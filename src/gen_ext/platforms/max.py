"""
Max/MSP platform implementation.

Generates Max/MSP externals using CMake and the max-sdk-base submodule.
"""

import platform as sys_platform
import shutil
import subprocess
from pathlib import Path
from string import Template
from typing import Optional

from gen_ext.core.builder import BuildResult
from gen_ext.core.parser import ExportInfo
from gen_ext.errors import BuildError, ProjectError
from gen_ext.platforms.base import Platform
from gen_ext.templates import get_max_templates_dir


class MaxPlatform(Platform):
    """Max/MSP platform implementation using CMake and max-sdk-base."""

    name = "max"

    # Version string for generated projects
    GENEXT_VERSION = "0.8.0"

    # max-sdk-base git repository
    MAX_SDK_REPO = "https://github.com/Cycling74/max-sdk-base.git"

    @property
    def extension(self) -> str:
        """Get the file extension for the current OS."""
        system = sys_platform.system().lower()
        if system == "darwin":
            return ".mxo"
        elif system == "windows":
            return ".mxe64"
        return ".mxl"

    def generate_project(
        self,
        export_info: ExportInfo,
        output_dir: Path,
        lib_name: str,
        buffers: list[str],
    ) -> None:
        """Generate Max/MSP project files."""
        templates_dir = get_max_templates_dir()
        if not templates_dir.is_dir():
            raise ProjectError(f"Max/MSP templates not found at {templates_dir}")

        # Copy static files
        static_files = [
            "gen_ext_max.cpp",
            "gen_ext_common_max.h",
            "_ext_max.cpp",
            "_ext_max.h",
            "gen_buffer_max.h",
        ]

        for filename in static_files:
            src = templates_dir / filename
            if src.exists():
                shutil.copy2(src, output_dir / filename)

        # Generate CMakeLists.txt
        self._generate_cmakelists(
            templates_dir / "CMakeLists.txt.template",
            output_dir / "CMakeLists.txt",
            export_info.name,
            lib_name,
        )

        # Generate gen_buffer.h
        self._generate_buffer_header(
            templates_dir / "gen_buffer.h.template",
            output_dir / "gen_buffer.h",
            buffers,
        )

        # Create build directory
        (output_dir / "build").mkdir(exist_ok=True)

        # Create externals output directory
        (output_dir / "externals").mkdir(exist_ok=True)

    def _generate_cmakelists(
        self,
        template_path: Path,
        output_path: Path,
        gen_name: str,
        lib_name: str,
    ) -> None:
        """Generate CMakeLists.txt from template."""
        if template_path.exists():
            template_content = template_path.read_text()
            template = Template(template_content)
            content = template.safe_substitute(
                gen_name=gen_name,
                lib_name=lib_name,
                genext_version=self.GENEXT_VERSION,
            )
        else:
            raise ProjectError(f"CMakeLists.txt template not found at {template_path}")

        output_path.write_text(content)

    def _generate_buffer_header(
        self,
        template_path: Path,
        output_path: Path,
        buffers: list[str],
    ) -> None:
        """Generate gen_buffer.h from template."""
        buffer_count = len(buffers)

        # Build buffer definitions
        buffer_defs = []
        for i, buf_name in enumerate(buffers):
            buffer_defs.append(f"#define WRAPPER_BUFFER_NAME_{i} {buf_name}")

        # Pad with commented-out placeholders
        for i in range(len(buffers), 5):
            buffer_defs.append(f"// #define WRAPPER_BUFFER_NAME_{i} array{i + 1}")

        if template_path.exists():
            template_content = template_path.read_text()
            template = Template(template_content)
            content = template.safe_substitute(
                buffer_count=buffer_count,
                buffer_definitions="\n".join(buffer_defs),
            )
        else:
            # Fallback: generate directly
            lines = [
                "// Buffer configuration for gen_ext Max/MSP wrapper",
                "// Auto-generated by gen-ext",
                "",
                f"#define WRAPPER_BUFFER_COUNT {buffer_count}",
                "",
            ]
            lines.extend(buffer_defs)
            content = "\n".join(lines) + "\n"

        output_path.write_text(content)

    def setup_sdk(self, project_dir: Path) -> bool:
        """
        Set up the max-sdk-base submodule.

        Returns True if SDK is ready, False if setup failed.
        """
        sdk_dir = project_dir / "max-sdk-base"

        if sdk_dir.exists() and (sdk_dir / "script" / "max-pretarget.cmake").exists():
            return True

        # Clone max-sdk-base
        try:
            result = subprocess.run(
                ["git", "clone", "--depth", "1", self.MAX_SDK_REPO, str(sdk_dir)],
                capture_output=True,
                text=True,
                cwd=project_dir,
            )
            return result.returncode == 0
        except FileNotFoundError:
            return False

    def build(
        self,
        project_dir: Path,
        clean: bool = False,
        verbose: bool = False,
    ) -> BuildResult:
        """Build Max/MSP external using CMake."""
        cmakelists = project_dir / "CMakeLists.txt"
        if not cmakelists.exists():
            raise BuildError(f"CMakeLists.txt not found in {project_dir}")

        # Ensure max-sdk-base is available
        if not self.setup_sdk(project_dir):
            raise BuildError(
                "Failed to set up max-sdk-base. Please ensure git is installed and run:\n"
                f"  cd {project_dir}\n"
                f"  git clone {self.MAX_SDK_REPO}"
            )

        build_dir = project_dir / "build"

        # Clean if requested
        if clean and build_dir.exists():
            shutil.rmtree(build_dir)

        build_dir.mkdir(exist_ok=True)

        # Configure with CMake
        configure_result = self._run_cmake_configure(project_dir, build_dir, verbose)
        if configure_result.returncode != 0:
            return BuildResult(
                success=False,
                platform="max",
                output_file=None,
                stdout=configure_result.stdout,
                stderr=configure_result.stderr,
                return_code=configure_result.returncode,
            )

        # Build
        build_result = self._run_cmake_build(build_dir, verbose)

        # Find output file
        output_file = self.find_output(project_dir)

        return BuildResult(
            success=build_result.returncode == 0,
            platform="max",
            output_file=output_file,
            stdout=build_result.stdout,
            stderr=build_result.stderr,
            return_code=build_result.returncode,
        )

    def _run_cmake_configure(
        self,
        project_dir: Path,
        build_dir: Path,
        verbose: bool = False,
    ) -> subprocess.CompletedProcess:
        """Run CMake configure step."""
        cmd = ["cmake", ".."]

        if verbose:
            process = subprocess.Popen(
                cmd,
                cwd=build_dir,
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,
                text=True,
            )

            output_lines = []
            for line in process.stdout:
                print(line, end="")
                output_lines.append(line)

            process.wait()

            return subprocess.CompletedProcess(
                args=cmd,
                returncode=process.returncode,
                stdout="".join(output_lines),
                stderr="",
            )
        else:
            return subprocess.run(
                cmd,
                cwd=build_dir,
                capture_output=True,
                text=True,
            )

    def _run_cmake_build(
        self,
        build_dir: Path,
        verbose: bool = False,
    ) -> subprocess.CompletedProcess:
        """Run CMake build step."""
        cmd = ["cmake", "--build", "."]

        if verbose:
            process = subprocess.Popen(
                cmd,
                cwd=build_dir,
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,
                text=True,
            )

            output_lines = []
            for line in process.stdout:
                print(line, end="")
                output_lines.append(line)

            process.wait()

            return subprocess.CompletedProcess(
                args=cmd,
                returncode=process.returncode,
                stdout="".join(output_lines),
                stderr="",
            )
        else:
            return subprocess.run(
                cmd,
                cwd=build_dir,
                capture_output=True,
                text=True,
            )

    def clean(self, project_dir: Path) -> None:
        """Clean build artifacts."""
        build_dir = project_dir / "build"
        if build_dir.exists():
            shutil.rmtree(build_dir)

    def find_output(self, project_dir: Path) -> Optional[Path]:
        """Find the built Max external file."""
        # Check externals directory (where max-posttarget.cmake puts output)
        externals_dir = project_dir / "externals"
        if externals_dir.is_dir():
            # Look for .mxo bundles (macOS) or .mxe64 (Windows)
            for pattern in ["*.mxo", "*.mxe64", "*.mxl*"]:
                for f in externals_dir.glob(pattern):
                    return f

        # Also check build directory
        build_dir = project_dir / "build"
        if build_dir.is_dir():
            for pattern in ["**/*.mxo", "**/*.mxe64", "**/*.mxl*"]:
                for f in build_dir.glob(pattern):
                    return f

        return None
